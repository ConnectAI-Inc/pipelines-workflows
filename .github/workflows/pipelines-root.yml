name: Pipelines Execute
run-name: Run Gruntwork Pipelines
on:
  workflow_call:
    secrets:
      GRUNTWORK_CODE_ACCESS_TOKEN:
        required: true

jobs:
  detect_changes:
    name: Detect Infrastructure Changes
    runs-on: ubuntu-latest
    steps:
      - name: Preflight Checks
        uses: gruntwork-io-team/pipelines-preflight-action@main
        with:
          GRUNTWORK_CODE_ACCESS_TOKEN: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}

      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: "Calculate Infrastructure Changes"
          step_status: "in_progress"

      - name: Pipelines Orchestrate
        id: orchestrate
        uses: gruntwork-io/pipelines-orchestrate@v2.0.4
        with:
          # We do this because the `GRUNTWORK_CODE_ACCESS_TOKEN` might not be present when vending a delegated account, even though it's always present in the main `infrastructure-live` account.
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: "Calculate Infrastructure Changes"
          step_status: "success"
          step_details: ${{ steps.orchestrate.outputs.jobs }}

    outputs:
      pipelines_jobs: ${{ steps.orchestrate.outputs.jobs }}
      pipelines_cli_version: ${{ steps.orchestrate.outputs.pipelines_cli_version }}

  pipelines_determine:
    name: ${{ matrix.jobs.ChangeType }} - ${{ matrix.jobs.WorkingDirectory }}
    needs: [detect_changes]
    runs-on: ubuntu-latest
    # GHA can't check for length, so we just check if there is an item in the 0 index
    if: fromJson(needs.detect_changes.outputs.pipelines_jobs)[0] != null
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        jobs: ${{ fromJson(needs.detect_changes.outputs.pipelines_jobs) }}
    steps:
      - name: Check out repo code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: ${{ matrix.jobs.ChangeType }} - ${{ matrix.jobs.WorkingDirectory }}
          step_status: "in_progress"

      - name: Bootstrap Workflow
        id: bootstrap
        uses: gruntwork-io-team/pipelines-bootstrap@main
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          change_type: ${{ matrix.jobs.ChangeType }}
          branch: ${{ matrix.jobs.Ref }}
          working_directory: ${{ matrix.jobs.WorkingDirectory }}
          account_id: ${{ matrix.jobs.AccountId }}
          terragrunt_command: ${{ matrix.jobs.Action.Command }} ${{ matrix.jobs.Action.Args }}
          additional_data: ${{ toJson(matrix.jobs.AdditionalData) }}
          child_account_id: ${{ matrix.jobs.AdditionalData.ChildAccountId }}
          account_names: ${{ matrix.jobs.AdditionalData.AccountNames }}

      - name: "[ProvisionAccount]: Provision New Account"
        id: provision_access_control
        if: ${{ steps.bootstrap.outputs.action == 'PROVISION_ACCOUNT' }}
        uses: gruntwork-io-team/pipelines-provision-account-action@main
        with:
          gruntwork_code_access_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}

      - name: "[Baseline]: Apply New Account Baseline Part 1"
        id: baseline
        if: steps.bootstrap.outputs.action == 'BASELINE_ACCOUNT'
        uses: gruntwork-io-team/pipelines-baseline-account-action@main
        with:
          gruntwork_code_access_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}

      - name: "[TerragruntExecute]: Authenticate with AWS and then Invoke Terragrunt"
        id: terragrunt
        if: ${{ steps.bootstrap.outputs.action == 'TERRAGRUNT_EXECUTE' }}
        uses: gruntwork-io-team/pipelines-aws-execute@main
        with:
          gruntwork_code_access_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          account_id: ${{ steps.bootstrap.outputs.account_id }}
          working_directory: ${{ steps.bootstrap.outputs.working_directory }}
          account_role_name: ${{ steps.bootstrap.outputs.role_name }}
          role_session_name: ${{ steps.bootstrap.outputs.role_session_name }}
          chain_account_id: ${{ steps.bootstrap.outputs.child_account_id }}
          chain_account_role_name: ${{ steps.bootstrap.outputs.child_acct_role_name }}
          gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}

      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        if: always()
        with:
          step_name: ${{ matrix.jobs.ChangeType }} - ${{ matrix.jobs.WorkingDirectory }}
          step_status: ${{ (steps.provision_access_control.conclusion == 'success' || steps.terragrunt.conclusion == 'success' || steps.baseline.conclusion == 'success') && 'success' || 'failed' }}
          step_details: "output will go here"

    outputs:
      account_id: ${{ matrix.jobs.AccountId }}
      branch: ${{ steps.bootstrap.outputs.branch }}
      action: ${{ steps.bootstrap.outputs.action }}
      working_directory: ${{ steps.bootstrap.outputs.working_directory }}
      terragrunt_command: ${{ steps.bootstrap.outputs.terragrunt_command }}
      additional_data: ${{ steps.bootstrap.outputs.additional_data }}
      child_account_id: ${{ steps.bootstrap.outputs.child_account_id }}
      new_account_name: ${{ steps.bootstrap.outputs.new_account_name }}
      team_account_names: ${{ steps.bootstrap.outputs.team_account_names }}

  pipelines_apply_baselines:
    name: ${{ matrix.jobs.Name }} - ${{ matrix.jobs.ID }}
    needs: [detect_changes, pipelines_determine]
    runs-on: ubuntu-latest
    # GHA can't check for length, so we just check if there is an item in the 0 index
    if: fromJson(needs.detect_changes.outputs.pipelines_jobs)[0].NewAccounts[0] != null
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        jobs: ${{ fromJson(needs.detect_changes.outputs.pipelines_jobs[0].NewAccounts) }}
    steps:
      - name: Check out repo code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: Baseline Account ${{ matrix.jobs.Name }} - ${{ matrix.jobs.ID }}
          step_status: "in_progress"

      - name: Bootstrap Workflow
        id: bootstrap
        uses: gruntwork-io-team/pipelines-bootstrap@main
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          change_type: ${{ needs.detect_changes.outputs.pipelines_jobs[0].ChangeType }}
          branch: ${{ needs.detect_changes.outputs.pipelines_jobs[0].Ref }}
          working_directory: ${{ needs.detect_changes.outputs.pipelines_jobs[0].WorkingDirectory }}
          account_id: ${{ needs.detect_changes.outputs.pipelines_jobs[0].AccountId }}
          terragrunt_command: ${{ needs.detect_changes.outputs.pipelines_jobs[0].Action.Command }} ${{ needs.detect_changes.outputs.pipelines_jobs[0].Action.Args }}
          additional_data: ${{ toJson(needs.detect_changes.outputs.pipelines_jobs[0].AdditionalData) }}
          child_account_id: ${{ needs.detect_changes.outputs.pipelines_jobs[0].AdditionalData.ChildAccountId }}
          account_names: ${{ needs.detect_changes.outputs.pipelines_jobs[0].AdditionalData.AccountNames }}

      # Auth to child account
      # THIS RETRIEVES PERMISSIONS TO BE ABLE TO RUN A PLAN/APPLY IN THE NEWLY CREATED CHILD ACCOUNT
      # The "AWSControlTowerExecution" role being assumed here is created by Control Tower in each account it provisions
      # and it can be assumed by a role in the management account.
      - name: "[Baseline]: Assume role new child account"
        shell: bash
        env:
          SESSION_NAME: ${{ steps.gruntwork_context.outputs.role_session_name }}
          CHILD_ACCOUNT: ${{ matrix.jobs.ID }}
        run: |
          RESPONSE="$(aws sts assume-role --role-arn "arn:aws:iam::$CHILD_ACCOUNT:role/AWSControlTowerExecution" --role-session-name "$SESSION_NAME")"
          ASSUMED_ROLE_CREDS="$(echo "$RESPONSE" | jq -r '.Credentials')"
          AWS_ACCESS_KEY_ID="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.AccessKeyId')"
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> "$GITHUB_ENV"
          echo "::add-mask::$AWS_ACCESS_KEY_ID"
          AWS_SECRET_ACCESS_KEY="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.SecretAccessKey')"
          echo AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" >> "$GITHUB_ENV"
          echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
          AWS_SESSION_TOKEN="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.SessionToken')"
          echo AWS_SESSION_TOKEN="$AWS_SESSION_TOKEN" >> "$GITHUB_ENV"
          echo "::add-mask::$AWS_SESSION_TOKEN"

      - name: "[Baseline]: Confirm Account Access"
        shell: bash
        env:
          CHILD_ACCOUNT: ${{ matrix.jobs.ID }}
          WORKING_DIRECTORY: ${{ matrix.jobs.Name }}
        run: aws sts get-caller-identity

      # This Bootstrap step is a workaround for the error that happens when running plan-all for the first time in a
      # new account with multiple modules. The error is:
      #
      #    OperationAborted: A conflicting conditional operation is currently in progress against this resource. Please try again.
      #    BucketAlreadyOwnedByYou: Your previous request to create the named bucket succeeded and you already own it.
      #
      # This happens because each module is trying to create buckets for state and logs when they do not exist.
      # Setting Terragrunt Parallelism to 1 does NOT prevent this error from happening. So we'll instead run an init in
      # a single module first to create the buckets so that subsequent run-all commands do not fail.
      - name: "[Baseline]: Bootstrap child account with state & logs S3 buckets"
        if: ${{ contains(steps.gruntwork_context.outputs.terragrunt_command, 'plan') }}
        uses: gruntwork-io/pipelines-execute@v3.0.0-beta4
        with:
          token: ${{ inputs.gruntwork_code_access_token }}
          pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}
          working_directory: "${{ matrix.jobs.Name }}/_global/account-baseline"
          terragrunt_command: "init"
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.gruntwork_context.outputs.branch }}
          gruntwork_config: "${{ steps.gruntwork_context.outputs.gruntwork_config }}"
          deploy_branch_name: ${{ steps.gruntwork_context.outputs.deploy_branch_name }}

      # Apply Access Control Roles and Baseline in Delegated Account
      - name: "[Baseline]: Bootstrap child account with access control roles, state & logs S3 buckets"
        uses: gruntwork-io/pipelines-execute@v3.0.0-beta4
        with:
          token: ${{ inputs.gruntwork_code_access_token }}
          pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}
          working_directory: "${{ matrix.jobs.Name }}/_global/account-baseline"
          terragrunt_command: ${{ steps.gruntwork_context.outputs.terragrunt_command }}
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.gruntwork_context.outputs.branch }}
          gruntwork_config: "${{ steps.gruntwork_context.outputs.gruntwork_config }}"
          deploy_branch_name: ${{ steps.gruntwork_context.outputs.deploy_branch_name }}



  pipelines_setup_access_control:
    name: "Pipelines Setup Access Control"
    needs: [detect_changes, pipelines_apply_baselines]
    runs-on: ubuntu-latest
    # GHA can't check for length, so we just check if there is an item in the 0 index
    if: fromJson(needs.detect_changes.outputs.pipelines_jobs)[0].NewAccounts[0] != null
    steps:
      - name: Check out repo code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bootstrap Workflow
        id: bootstrap
        uses: gruntwork-io-team/pipelines-bootstrap@main
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          change_type: ${{ needs.detect_changes.outputs.pipelines_jobs[0].ChangeType }}
          branch: ${{ needs.detect_changes.outputs.pipelines_jobs[0].Ref }}
          working_directory: ${{ needs.detect_changes.outputs.pipelines_jobs[0].WorkingDirectory }}
          account_id: ${{ needs.detect_changes.outputs.pipelines_jobs[0].AccountId }}
          terragrunt_command: ${{ needs.detect_changes.outputs.pipelines_jobs[0].Action.Command }} ${{ needs.detect_changes.outputs.pipelines_jobs[0].Action.Args }}
          additional_data: ${{ toJson(needs.detect_changes.outputs.pipelines_jobs[0].AdditionalData) }}
          child_account_id: ${{ needs.detect_changes.outputs.pipelines_jobs[0].AdditionalData.ChildAccountId }}
          account_names: ${{ needs.detect_changes.outputs.pipelines_jobs[0].AdditionalData.AccountNames }}

      # Create Access Control PR
      # Merge Access Control PR
      - name: "[ProvisionAccount]: Setup Access Control PR"
        id: access_control_pr
        if: ${{ steps.bootstrap.outputs.action == 'apply' }}
        uses: gruntwork-io-team/pipelines-provision-access-control-action@main
        with:
          gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}
          gruntwork_code_access_token: ${{ inputs.GRUNTWORK_CODE_ACCESS_TOKEN }}
          # TODO - this needs to be a different token that has enhanced scopes for creating repos
          manage_repo_token: ${{ inputs.GRUNTWORK_CODE_ACCESS_TOKEN }}

      # Create Delegated Repo
      # Create PR in Delegated Repo
      - name: "[ProvisionDelegatedRepo]: Setup delegated Repo"
        id: provision_delegated_repo
        uses: gruntwork-io-team/pipelines-provision-repo-action@main
        with:
          gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}
          gruntwork_code_access_token: ${{ inputs.GRUNTWORK_CODE_ACCESS_TOKEN }}
          # TODO - this needs to be a different token that has enhanced scopes for creating repos
          manage_repo_token: ${{ inputs.GRUNTWORK_CODE_ACCESS_TOKEN }}
